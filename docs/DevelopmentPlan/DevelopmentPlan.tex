\documentclass{article}

\usepackage{booktabs}
\usepackage{tabularx}
\usepackage{multirow}

\title{Development Plan\\\progname}

\author{\authname}

\date{}

\input{../Comments}
\input{../Common}

\begin{document}

\maketitle

\begin{table}[hp]
\caption{Revision History} \label{TblRevisionHistory}
\begin{tabularx}{\textwidth}{llX}
\toprule
\textbf{Date} & \textbf{Developer(s)} & \textbf{Change}\\
\midrule
2023/09/15 & All & Initial addition of all sections\\
2023/09/23 & Ethan & Updated team member roles chart (need to fix formatting), touched up workflow plan, technology, and project scheduling  \\
2023/09/25 & All & Final commit for Development plan deliverable\\
2023/11/14 & All & Finalize PoC Plan\\
2023/11/14 & Ethan & Prof instances updated to Professor. Acronym table added. Grammar issues fixed. Fixed inconsistent use of master vs main in workflow plan, as well as added information about use of git issues and tags. \\

\bottomrule
\end{tabularx}
\end{table}

This document outlines the rules and processes that the team will follow during the development process. All information about how the team will communicate and coordinate, along with what each team member is responsible for overseeing, can be found here.

\section{Symbols, Abbreviations and Acronyms}

\renewcommand{\arraystretch}{1.2}
\begin{tabular}{l l} 
  \toprule		
  \textbf{symbol} & \textbf{description}\\
  \midrule 
  UI & User Interface\\
  NFR & Non-functional Requirement \\
  PoC & Proof of Concept \\
  VS & Visual Studio\\
  \bottomrule
\end{tabular}\\

\section{Team Meeting Plan}

Our plan is to have a meeting for every capstone lecture that is not for Software Engineering or is not running. When we are behind on a deliverable, we will schedule a meeting during our time between classes to meet and go over what we will need to accomplish before the due date.

\section{Team Communication Plan}
For most issues, we will communicate over Discord with each other. Matthew is in charge of communicating with the professors/supervisor. In addition, we will also have a meeting with Irene Yuan every week during Irene Yuan's Office hours. 
\newpage
\section{Team Member Roles}
The following responsibilities are required of each team member:
\begin{itemize}
    \item Each team member will contribute to full-stack development.
    \item All team members will be present at team meetings, however, if a team member cannot attend for some reason they must let the team know at least an hour beforehand and give a reason.
    \item If a team member would like to change roles, they must discuss with the group so that a suitable swapping of roles can be done with another team member
\end{itemize}

\begin{table}[h]
\centering
\begin{tabular}{|p{1.3in}|p{2in}|p{2.6in}|ll}
\cline{1-3}
Team member& Role(s)& Responsibilities &  &  \\ \cline{1-3}
\multirow{2}{*}{Matthew Collard}   & Team Liaison & Communicates with the Supervisor/Professor and any stakeholders &  &  \\ \cline{2-3} & Front-End Lead Developer & Make sure user interface is clear to the user, and functioning properly. Makes sure we are on track to complete UI goals on time &  &  \\ \cline{1-3}
\multirow{2}{*}{Sam Gorman} & GitHub Administrator & Merge and maintain GitHub branches. Responsible for merging dev into main branch  &  &  \\ \cline{2-3} & Non-Functional Requirement Lead & Makes sure every NFR is implemented in the design &  &  \\ \cline{1-3}
\multirow{2}{*}{Kieran Gara}  & Final Revision Editor  & Last editor of project documents. Makes sure team adheres to writing guidelines   &  &  \\ \cline{2-3}& Back-End Lead Developer  & Leads development process and makes sure team is on-track to complete implementation goals on time  &  &  \\ \cline{1-3}
\multirow{2}{*}{Ethan Kannampuzha} & Functional Requirement Lead     & Makes sure every functional requirement is implemented in the design &  &  \\ \cline{2-3} & Meeting Minute Writer & Keeps track and writes down meeting minutes &  &  \\ \cline{1-3}
\end{tabular}
\end{table}



\section{Workflow Plan}

\begin{itemize}
	\item For Git, we will have a master branch called main that will always have a working code base and up-to-date documentation. We will have a second branch called dev, this is the development branch, and all our new changes get merged into this branch. It is meant to be unstable and most of our issues will pop up in this branch. Every time dev has a stable build, we will push the code into main. We will have branches off of dev that we are going to use as our feature branches, every new line of code gets written in these branches, and when the feature is done it will get merged into dev. This double buffer system ensures we always have working code easily accessible in main. Sam will be responsible for merging dev into main. Continuing on, we will also be using Git issues for issue tracking. Team members will create and assign issues depending on the work that needs to be done. Additionally, tags will be used to differentiate the subject matter that the issue falls under.
 \item Document changes are the only changes that can be merged directly from branch to main. All source code changes go through the development branch first.
    \item Changes into the dev and main branches will be done through formal pull requests. Reviewers will not be strictly necessary for these PRs, as this is mainly being used as a way to track merges and make sure branches are up to date before merging in. Reviews from other team members are recommended when working on the same file/directory. 
	\item GitHub issues will be created for each team meeting, lecture period, document revision, and feature change. Additionally, issues for meetings will be used to track who attended and a general overview of the agenda. GitHub project boards will be used to keep track of deliverable deadlines and GitHub issues for document and dev work will be broken up by sub-tasks for each deliverable. These project boards and issues will be the main project management tools used for the project.
\end{itemize}

\section{Proof of Concept Demonstration Plan}
The main risks of the project are:
\begin{itemize}
    \item Implementing AR elements into the game
    \item Networking between multiple devices
\end{itemize}
To demonstrate that these risks can be overcome, the following will be shown in the PoC Demo:
\begin{itemize}
    \item Show that a digital object can be overlayed on top of a real-life surface 
    \item Demo an example of at least two users being able to send and receive chat messages
    \item Demo an example of at least two users being able to connect to a live audio chat
    \item Demo at least two users being able to interact with the same AR element and have it be affected on both devices
\end{itemize}
If our PoC shows that our AR implementation is not working, then the entire scope of the project might be too large, and we would have to reduce the scope as AR implementation might not be as simple as we thought it would be. This would allow us to focus more time on these core components as opposed to adding more features.
If the networking between multiple devices is not working, we would have to reconsider how the users can cooperate with each other to play the game. We could reduce our scope to only text messages as a final implementation instead of voice and text messages. 


%The plan for the proof of concept is to have a simple AR program working that can allow two users to interact in some way. This will be used as a trial run for the technology and the actual game will be built off of the POC afterwards. 

\section{Technology}

\begin{itemize}
\item Coding Language: C\# (Unity) Unity has built-in AR modules we could use to implement our project more easily. 
\item Test Framework: NUnit. Nunit has great support for the .net(C\#) unit testing and can automate unit testing for us. 
\item Code Coverage measuring tool: dotCover. DotCover integrates with VS and is built for C\#, so it is perfect for our usages, and it has specific support just for Unity projects. 
\item Specific plans for Continuous Integration (CI): Will be doing extensive unit testing as well as code linting. Hard to have full CI/CD in a Unity game engine
\item Libraries: To be expanded based on project needs
    \begin{itemize}
    \item C\# standard library
    \end{itemize}
\item Tool/Framework: Unity
\end{itemize}

\section{Coding Standard}
\begin{itemize}
    \item Variable name syntax: camelCase
    \item Function name syntax: PascalCase
    \item Class name syntax: PascalCase
    \item Brackets: Same line (Ex. If () \{)
    \item Public/ Private: Use private when possible
    \item Indent: Tab 
\end{itemize}

\section{Project Scheduling}

The team will use a Google Calendar to schedule goals for milestone progress and deliverable deadlines. Additionally, GitHub project boards will be used to keep track of ongoing deliverables, and GitHub issues will be used to assign sub-tasks for these deliverables. for As a general rule, the next deliverable will be started a minimum of one week before the previous deliverable is due for documentation. Code development will be ongoing throughout with deadlines set for various components. 
\end{document}